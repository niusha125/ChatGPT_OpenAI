import { isPromise, lazy } from 'promist';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class Errorish extends Error {
  /**
   * An optional `source` -should reference the object that originated the `Errorish`.
   */

  /**
   * An optional `data` field.
   */
  constructor(message, source, data) {
    super(message || undefined);

    _defineProperty(this, "source", void 0);

    _defineProperty(this, "data", void 0);

    this.source = source;
    this.data = data || {};
  }
  /**
   * Custom Error name: 'Errorish'
   */


  get name() {
    return 'Errorish';
  }
  /**
   * References `source.root` is an instance of `Errorish`; references `source` if it is an instance of `Error`; otherwise it references itself.
   */


  get root() {
    if (this.source instanceof Errorish) return this.source.root;
    return this.source instanceof Error ? this.source : this;
  }
  /**
   * Sets the `data` field and returns itself.
   */


  set(data) {
    this.data = data;
    return this;
  }
  /**
   * Assigns `data` to the `data` field and returns itself.
   */


  assign(data) {
    Object.assign(this.data, data);
    return this;
  }

}

/**
 * Default values for error creation and normalization when an options object is not passed or lacks a particular property. They can be reset via `scope.set`. See `ICoreOptions`.
 */

const defaults = {
  name: 'Error',
  message: 'An error occurred',
  Errorish: Errorish,
  normalize: true,
  capture: true,
  allow: ['string'],
  Error: Error
};

/**
 * Normalizes an Error -it assumes an instance of Error is passed. It guarantees the error will have a `name`, `message`, and `stack` properties.
 */

function normalize(error, options) {
  const opts = Object.assign({}, defaults, options);

  if (!error.name) {
    error.name = error.constructor && error.constructor.name || opts.name;
  }

  if (!error.message) error.message = opts.message;
  if (!error.stack) error.stack = "Error: ".concat(error.message);
  return error;
}

function stringify(message, options) {
  if (typeof message === 'string') return message;

  try {
    return JSON.stringify(message);
  } catch (e) {
    return options.message;
  }
}

function trunk(error, options, data) {
  if (error instanceof options.Error) return error;
  let message = error && typeof error === 'object' && error.hasOwnProperty('message') ? error.message : error;
  message = options.allow.includes(typeof message) ? stringify(message, options) : options.message;
  error = new options.Errorish(message, error, data);

  if (options.capture && Error.captureStackTrace) {
    Error.captureStackTrace(error, options.Errorish);
  }

  return error;
}

/**
 * Will return `error` if it is an instance of `options.Error` -by default, and instance of `Error`. Otherwise, it will instantiate and return an `Error` of class `options.Errorish` -`Errorish` by default. This newly created error -if created- would have:
 *  - whatever you passed as an `error` as its `source` field.
 *  - whatever you passed as `data` as its `data` field.
 */

function ensure(error, options, data) {
  const opts = Object.assign({}, defaults, options);
  return opts.normalize ? normalize(trunk(error, opts, data), opts) : trunk(error, opts, data);
}

/**
 * Returns a promise rejection with `error`, having called `ensure` on it.
 */

function rejects(_x, _x2, _x3) {
  return _rejects.apply(this, arguments);
}

function _rejects() {
  _rejects = _asyncToGenerator(function* (error, options, data) {
    const condition = options && options.hasOwnProperty('case') ? options.case : true;
    if (condition) throw ensure(error, options, data);
  });
  return _rejects.apply(this, arguments);
}

/**
 * Returns the result of `fn`; if it throws, it will call `ensure` on the thrown error and throw it. `fn` can be an *async* function -it will be automatically detected.
 */

function throws(fn, options, data) {
  try {
    const response = fn();
    if (!isPromise(response)) return response; // if it is a promise
    // in case res was a lazy promise

    return lazy.fn(() => {
      return response.catch(err => rejects(err, options, data));
    });
  } catch (err) {
    throw ensure(err, options, data);
  }
}

const root = {
  name: null,
  ensure,
  throws,
  rejects,
  normalize
};
const scopes = {};
const values = {};

/**
 * Allows the creation of specific scopes with different sets of default options. If a particular option is nor defined for a scope, it will fall back to the root scope value for that option -the root scope is the one the `ensure`, `throws`, `rejects`, and `normalize` functions as exported from `errorish` entry point belong to by default.
 */

const scope = {
  /**
   * Gets a scope by name -it is created if it doesn't exist. If no name is passed, the root scope will be returned.
   */
  get(name) {
    if (!name) return root;

    if (!scopes.hasOwnProperty(name)) {
      if (!values.hasOwnProperty(name)) values[name] = {};
      const options = values[name];
      scopes[name] = {
        name,

        ensure() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          args[1] = Object.assign({}, options, args[1]);
          return ensure(args[0], ...args.slice(1));
        },

        throws() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          args[1] = Object.assign({}, options, args[1]);
          return throws(args[0], ...args.slice(1));
        },

        rejects() {
          var _arguments = arguments;
          return _asyncToGenerator(function* () {
            for (var _len3 = _arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = _arguments[_key3];
            }

            args[1] = Object.assign({}, options, args[1]);
            return rejects(args[0], ...args.slice(1));
          })();
        },

        normalize() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          args[1] = Object.assign({}, options, args[1]);
          return normalize(args[0], ...args.slice(1));
        }

      };
    }

    return scopes[name];
  },

  /**
   * Sets default options for a scope, taking the name of the scope as the first argument, and the `ICoreOptions` options as the second. If no name is passed and a single `ICoreOptions` argument is in its place, it will set the defaults for the root scope. It will also return the scope.
   */
  set() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    const name = args.find(x => typeof x === 'string');
    const options = args.find(x => typeof x === 'object');
    if (!name) Object.assign(defaults, options);else {
      if (!values.hasOwnProperty(name)) values[name] = {};
      Object.assign(values[name], options);
    }
    return scope.get(name);
  }

};

export { Errorish, ensure, normalize, rejects, scope, throws };

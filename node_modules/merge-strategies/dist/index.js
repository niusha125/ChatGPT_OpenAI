"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shallow = shallow;
exports.merge = merge;
exports.deep = deep;

var _lodash = _interopRequireDefault(require("lodash.mergewith"));

var _lodash2 = _interopRequireDefault(require("lodash.clonedeep"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * If both `defaults` and `value` are objects, they will be shallow merged. Mutations to the returned object won't have an effect over `defaults`.
 */
function shallow(defaults, value) {
  const data = typeof value === 'object' && value !== null && !Array.isArray(value) && typeof defaults === 'object' && defaults !== null && !Array.isArray(defaults) ? Object.assign((0, _lodash2.default)(defaults), value) : value;
  return data;
}
/**
 * If both `defaults` and `value` are objects, they will be deep merged. Arrays won't be merged. Mutations to the returned object won't have an effect over `defaults`.
 */


function merge(defaults, value) {
  const {
    data
  } = (0, _lodash.default)({}, {
    data: defaults
  }, {
    data: value
  }, (obj, src) => Array.isArray(src) || Array.isArray(obj) ? src : undefined);
  return data;
}
/**
 * If both the `defaults` and `value` are objects, they will be deep merged. Arrays will be concatenated. Mutations to the returned object won't have an effect over `defaults`.
 */


function deep(defaults, value) {
  const {
    data
  } = (0, _lodash.default)({}, {
    data: defaults
  }, {
    data: value
  }, (obj, src) => {
    const a = Array.isArray(obj);
    const b = Array.isArray(src);
    if (!a && !b) return;
    return a && b ? obj.concat(src) : src;
  });
  return data;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJzaGFsbG93IiwiZGVmYXVsdHMiLCJ2YWx1ZSIsImRhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJhc3NpZ24iLCJtZXJnZSIsIm9iaiIsInNyYyIsInVuZGVmaW5lZCIsImRlZXAiLCJhIiwiYiIsImNvbmNhdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7Ozs7QUFJQTs7O0FBR08sU0FBU0EsT0FBVCxDQUFvQ0MsUUFBcEMsRUFBaURDLEtBQWpELEVBQXdFO0FBQzdFLFFBQU1DLElBQVMsR0FDYixPQUFPRCxLQUFQLEtBQWlCLFFBQWpCLElBQ0FBLEtBQUssS0FBSyxJQURWLElBRUEsQ0FBQ0UsS0FBSyxDQUFDQyxPQUFOLENBQWNILEtBQWQsQ0FGRCxJQUdBLE9BQU9ELFFBQVAsS0FBb0IsUUFIcEIsSUFJQUEsUUFBUSxLQUFLLElBSmIsSUFLQSxDQUFDRyxLQUFLLENBQUNDLE9BQU4sQ0FBY0osUUFBZCxDQUxELEdBTUlLLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLHNCQUFVTixRQUFWLENBQWQsRUFBbUNDLEtBQW5DLENBTkosR0FPSUEsS0FSTjtBQVNBLFNBQU9DLElBQVA7QUFDRDtBQUVEOzs7OztBQUdPLFNBQVNLLEtBQVQsQ0FBa0NQLFFBQWxDLEVBQStDQyxLQUEvQyxFQUFzRTtBQUMzRSxRQUFNO0FBQUVDLElBQUFBO0FBQUYsTUFBZ0IscUJBQ3BCLEVBRG9CLEVBRXBCO0FBQUVBLElBQUFBLElBQUksRUFBRUY7QUFBUixHQUZvQixFQUdwQjtBQUFFRSxJQUFBQSxJQUFJLEVBQUVEO0FBQVIsR0FIb0IsRUFJcEIsQ0FBQ08sR0FBRCxFQUFXQyxHQUFYLEtBQ0VOLEtBQUssQ0FBQ0MsT0FBTixDQUFjSyxHQUFkLEtBQXNCTixLQUFLLENBQUNDLE9BQU4sQ0FBY0ksR0FBZCxDQUF0QixHQUEyQ0MsR0FBM0MsR0FBaURDLFNBTC9CLENBQXRCO0FBT0EsU0FBT1IsSUFBUDtBQUNEO0FBRUQ7Ozs7O0FBR08sU0FBU1MsSUFBVCxDQUFpQ1gsUUFBakMsRUFBOENDLEtBQTlDLEVBQXFFO0FBQzFFLFFBQU07QUFBRUMsSUFBQUE7QUFBRixNQUFnQixxQkFDcEIsRUFEb0IsRUFFcEI7QUFBRUEsSUFBQUEsSUFBSSxFQUFFRjtBQUFSLEdBRm9CLEVBR3BCO0FBQUVFLElBQUFBLElBQUksRUFBRUQ7QUFBUixHQUhvQixFQUlwQixDQUFDTyxHQUFELEVBQVdDLEdBQVgsS0FBd0I7QUFDdEIsVUFBTUcsQ0FBQyxHQUFHVCxLQUFLLENBQUNDLE9BQU4sQ0FBY0ksR0FBZCxDQUFWO0FBQ0EsVUFBTUssQ0FBQyxHQUFHVixLQUFLLENBQUNDLE9BQU4sQ0FBY0ssR0FBZCxDQUFWO0FBQ0EsUUFBSSxDQUFDRyxDQUFELElBQU0sQ0FBQ0MsQ0FBWCxFQUFjO0FBQ2QsV0FBT0QsQ0FBQyxJQUFJQyxDQUFMLEdBQVNMLEdBQUcsQ0FBQ00sTUFBSixDQUFXTCxHQUFYLENBQVQsR0FBMkJBLEdBQWxDO0FBQ0QsR0FUbUIsQ0FBdEI7QUFXQSxTQUFPUCxJQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWVyZ2V3aXRoIGZyb20gJ2xvZGFzaC5tZXJnZXdpdGgnO1xuaW1wb3J0IGNsb25lZGVlcCBmcm9tICdsb2Rhc2guY2xvbmVkZWVwJztcblxuZXhwb3J0IHR5cGUgTWVyZ2U8RCwgVD4gPSBUICYgKEQgZXh0ZW5kcyBvYmplY3QgPyBUICYgRCA6IFQpO1xuXG4vKipcbiAqIElmIGJvdGggYGRlZmF1bHRzYCBhbmQgYHZhbHVlYCBhcmUgb2JqZWN0cywgdGhleSB3aWxsIGJlIHNoYWxsb3cgbWVyZ2VkLiBNdXRhdGlvbnMgdG8gdGhlIHJldHVybmVkIG9iamVjdCB3b24ndCBoYXZlIGFuIGVmZmVjdCBvdmVyIGBkZWZhdWx0c2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93PEQsIFQgPSBQYXJ0aWFsPEQ+PihkZWZhdWx0czogRCwgdmFsdWU6IFQpOiBNZXJnZTxELCBUPiB7XG4gIGNvbnN0IGRhdGE6IGFueSA9XG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgdHlwZW9mIGRlZmF1bHRzID09PSAnb2JqZWN0JyAmJlxuICAgIGRlZmF1bHRzICE9PSBudWxsICYmXG4gICAgIUFycmF5LmlzQXJyYXkoZGVmYXVsdHMpXG4gICAgICA/IE9iamVjdC5hc3NpZ24oY2xvbmVkZWVwKGRlZmF1bHRzKSwgdmFsdWUpXG4gICAgICA6IHZhbHVlO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBJZiBib3RoIGBkZWZhdWx0c2AgYW5kIGB2YWx1ZWAgYXJlIG9iamVjdHMsIHRoZXkgd2lsbCBiZSBkZWVwIG1lcmdlZC4gQXJyYXlzIHdvbid0IGJlIG1lcmdlZC4gTXV0YXRpb25zIHRvIHRoZSByZXR1cm5lZCBvYmplY3Qgd29uJ3QgaGF2ZSBhbiBlZmZlY3Qgb3ZlciBgZGVmYXVsdHNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8RCwgVCA9IFBhcnRpYWw8RD4+KGRlZmF1bHRzOiBELCB2YWx1ZTogVCk6IE1lcmdlPEQsIFQ+IHtcbiAgY29uc3QgeyBkYXRhIH06IGFueSA9IG1lcmdld2l0aChcbiAgICB7fSxcbiAgICB7IGRhdGE6IGRlZmF1bHRzIH0sXG4gICAgeyBkYXRhOiB2YWx1ZSB9LFxuICAgIChvYmo6IGFueSwgc3JjOiBhbnkpID0+XG4gICAgICBBcnJheS5pc0FycmF5KHNyYykgfHwgQXJyYXkuaXNBcnJheShvYmopID8gc3JjIDogdW5kZWZpbmVkXG4gICk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIElmIGJvdGggdGhlIGBkZWZhdWx0c2AgYW5kIGB2YWx1ZWAgYXJlIG9iamVjdHMsIHRoZXkgd2lsbCBiZSBkZWVwIG1lcmdlZC4gQXJyYXlzIHdpbGwgYmUgY29uY2F0ZW5hdGVkLiBNdXRhdGlvbnMgdG8gdGhlIHJldHVybmVkIG9iamVjdCB3b24ndCBoYXZlIGFuIGVmZmVjdCBvdmVyIGBkZWZhdWx0c2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwPEQsIFQgPSBQYXJ0aWFsPEQ+PihkZWZhdWx0czogRCwgdmFsdWU6IFQpOiBNZXJnZTxELCBUPiB7XG4gIGNvbnN0IHsgZGF0YSB9OiBhbnkgPSBtZXJnZXdpdGgoXG4gICAge30sXG4gICAgeyBkYXRhOiBkZWZhdWx0cyB9LFxuICAgIHsgZGF0YTogdmFsdWUgfSxcbiAgICAob2JqOiBhbnksIHNyYzogYW55KSA9PiB7XG4gICAgICBjb25zdCBhID0gQXJyYXkuaXNBcnJheShvYmopO1xuICAgICAgY29uc3QgYiA9IEFycmF5LmlzQXJyYXkoc3JjKTtcbiAgICAgIGlmICghYSAmJiAhYikgcmV0dXJuO1xuICAgICAgcmV0dXJuIGEgJiYgYiA/IG9iai5jb25jYXQoc3JjKSA6IHNyYztcbiAgICB9XG4gICk7XG4gIHJldHVybiBkYXRhO1xufVxuIl19
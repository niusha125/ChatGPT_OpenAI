'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var promist = require('promist');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class Errorish extends Error {
  /**
   * An optional `source` -should reference the object that originated the `Errorish`.
   */

  /**
   * An optional `data` field.
   */
  constructor(message, source, data) {
    super(message || undefined);

    _defineProperty(this, "source", void 0);

    _defineProperty(this, "data", void 0);

    this.source = source;
    this.data = data || {};
  }
  /**
   * Custom Error name: 'Errorish'
   */


  get name() {
    return 'Errorish';
  }
  /**
   * References `source.root` is an instance of `Errorish`; references `source` if it is an instance of `Error`; otherwise it references itself.
   */


  get root() {
    if (this.source instanceof Errorish) return this.source.root;
    return this.source instanceof Error ? this.source : this;
  }
  /**
   * Sets the `data` field and returns itself.
   */


  set(data) {
    this.data = data;
    return this;
  }
  /**
   * Assigns `data` to the `data` field and returns itself.
   */


  assign(data) {
    Object.assign(this.data, data);
    return this;
  }

}

/**
 * Default values for error creation and normalization when an options object is not passed or lacks a particular property. They can be reset via `scope.set`. See `ICoreOptions`.
 */

const defaults = {
  name: 'Error',
  message: 'An error occurred',
  Errorish: Errorish,
  normalize: true,
  capture: true,
  allow: ['string'],
  Error: Error
};

/**
 * Normalizes an Error -it assumes an instance of Error is passed. It guarantees the error will have a `name`, `message`, and `stack` properties.
 */

function normalize(error, options) {
  const opts = Object.assign({}, defaults, options);

  if (!error.name) {
    error.name = error.constructor && error.constructor.name || opts.name;
  }

  if (!error.message) error.message = opts.message;
  if (!error.stack) error.stack = `Error: ${error.message}`;
  return error;
}

function stringify(message, options) {
  if (typeof message === 'string') return message;

  try {
    return JSON.stringify(message);
  } catch (e) {
    return options.message;
  }
}

function trunk(error, options, data) {
  if (error instanceof options.Error) return error;
  let message = error && typeof error === 'object' && error.hasOwnProperty('message') ? error.message : error;
  message = options.allow.includes(typeof message) ? stringify(message, options) : options.message;
  error = new options.Errorish(message, error, data);

  if (options.capture && Error.captureStackTrace) {
    Error.captureStackTrace(error, options.Errorish);
  }

  return error;
}

/**
 * Will return `error` if it is an instance of `options.Error` -by default, and instance of `Error`. Otherwise, it will instantiate and return an `Error` of class `options.Errorish` -`Errorish` by default. This newly created error -if created- would have:
 *  - whatever you passed as an `error` as its `source` field.
 *  - whatever you passed as `data` as its `data` field.
 */

function ensure(error, options, data) {
  const opts = Object.assign({}, defaults, options);
  return opts.normalize ? normalize(trunk(error, opts, data), opts) : trunk(error, opts, data);
}

/**
 * Returns a promise rejection with `error`, having called `ensure` on it.
 */

async function rejects(error, options, data) {
  const condition = options && options.hasOwnProperty('case') ? options.case : true;
  if (condition) throw ensure(error, options, data);
}

/**
 * Returns the result of `fn`; if it throws, it will call `ensure` on the thrown error and throw it. `fn` can be an *async* function -it will be automatically detected.
 */

function throws(fn, options, data) {
  try {
    const response = fn();
    if (!promist.isPromise(response)) return response; // if it is a promise
    // in case res was a lazy promise

    return promist.lazy.fn(() => {
      return response.catch(err => rejects(err, options, data));
    });
  } catch (err) {
    throw ensure(err, options, data);
  }
}

const root = {
  name: null,
  ensure,
  throws,
  rejects,
  normalize
};
const scopes = {};
const values = {};

/**
 * Allows the creation of specific scopes with different sets of default options. If a particular option is nor defined for a scope, it will fall back to the root scope value for that option -the root scope is the one the `ensure`, `throws`, `rejects`, and `normalize` functions as exported from `errorish` entry point belong to by default.
 */

const scope = {
  /**
   * Gets a scope by name -it is created if it doesn't exist. If no name is passed, the root scope will be returned.
   */
  get(name) {
    if (!name) return root;

    if (!scopes.hasOwnProperty(name)) {
      if (!values.hasOwnProperty(name)) values[name] = {};
      const options = values[name];
      scopes[name] = {
        name,

        ensure(...args) {
          args[1] = Object.assign({}, options, args[1]);
          return ensure(args[0], ...args.slice(1));
        },

        throws(...args) {
          args[1] = Object.assign({}, options, args[1]);
          return throws(args[0], ...args.slice(1));
        },

        async rejects(...args) {
          args[1] = Object.assign({}, options, args[1]);
          return rejects(args[0], ...args.slice(1));
        },

        normalize(...args) {
          args[1] = Object.assign({}, options, args[1]);
          return normalize(args[0], ...args.slice(1));
        }

      };
    }

    return scopes[name];
  },

  /**
   * Sets default options for a scope, taking the name of the scope as the first argument, and the `ICoreOptions` options as the second. If no name is passed and a single `ICoreOptions` argument is in its place, it will set the defaults for the root scope. It will also return the scope.
   */
  set(...args) {
    const name = args.find(x => typeof x === 'string');
    const options = args.find(x => typeof x === 'object');
    if (!name) Object.assign(defaults, options);else {
      if (!values.hasOwnProperty(name)) values[name] = {};
      Object.assign(values[name], options);
    }
    return scope.get(name);
  }

};

exports.Errorish = Errorish;
exports.ensure = ensure;
exports.normalize = normalize;
exports.rejects = rejects;
exports.scope = scope;
exports.throws = throws;

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const defaults = {
  cancellable: false,
  resetable: false,
  deferrable: false,
  timed: false,
  status: false
};
const MARK_SYMBOL = Symbol('mark');
var mark = {
  set(promise, ...as) {
    if (!promise.hasOwnProperty(MARK_SYMBOL)) {
      Object.assign(promise, {
        [MARK_SYMBOL]: Object.assign({}, defaults)
      });
    }

    as.forEach(key => promise[MARK_SYMBOL][key] = true);
    return promise;
  },

  get(promise, as) {
    return Boolean(promise.hasOwnProperty(MARK_SYMBOL) && promise[MARK_SYMBOL][as]);
  }

};

function deferred() {
  let _resolve;

  let _reject;

  const p = new Promise((resolve, reject) => {
    _resolve = resolve;
    _reject = reject;
  });
  mark.set(p, 'deferrable');
  p.resolve = _resolve;
  p.reject = _reject;
  return p;
}

function immediate() {
  return new Promise(resolve => setImmediate(resolve));
}

const INTERCEPT_SYMBOL = Symbol('intercept');
const RESPONSE_SYMBOL = Symbol('response');
function intercept(promise, interceptFn) {
  const p = promise;
  let intercept = p[INTERCEPT_SYMBOL];

  if (intercept) {
    p[RESPONSE_SYMBOL] = null;
    intercept.push(interceptFn);
    return promise;
  }

  p[INTERCEPT_SYMBOL] = intercept = [interceptFn];
  const _then = promise.then;

  const run = () => {
    const res = p[RESPONSE_SYMBOL];
    return res || (p[RESPONSE_SYMBOL] = intercept.reduce((acc, fn) => fn(acc), Promise.resolve(_then.call(promise, x => x))));
  };

  promise.then = (...args) => run().then(...args);

  promise.catch = (...args) => run().catch(...args);

  if (promise.hasOwnProperty('finally')) {
    promise.finally = (...args) => run().finally(...args);
  }

  return promise;
}

function isPromise(value) {
  return Boolean(value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function');
}

function lazy(executor) {
  const promise = new Promise(resolve => resolve());
  let p;
  return intercept(promise, () => {
    return p || (p = new Promise(executor));
  });
}

lazy.fn = function lazyFn(fn) {
  return lazy((resolve, reject) => {
    try {
      const res = fn();
      if (isPromise(res)) res.then(resolve).catch(reject);else resolve(res);
    } catch (err) {
      reject(err);
    }
  });
};

function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function waitUntil(testCb, ms = 20) {
  const callCb = () => {
    return Promise.resolve(testCb()).then(ans => {
      return ans || wait(ms).then(() => callCb());
    });
  };

  return callCb().then(() => {});
}

function asNew(p, create) {
  return create ? p.then(x => x) : p;
}

function cancellable(promise, create) {
  const p = asNew(promise, create);
  if (mark.get(p, 'cancellable')) return p;
  mark.set(p, 'cancellable');
  let cancellable = true;
  p.cancelled = false;

  p.cancel = function cancel() {
    if (!cancellable) return;
    this.cancelled = true;
  };

  const unfulfilled = new Promise(() => {});
  p.then(() => cancellable = false).catch(() => cancellable = false);
  return intercept(p, px => {
    return px.then(val => p.cancelled ? unfulfilled : val).catch(err => p.cancelled ? unfulfilled : Promise.reject(err));
  });
}

function deferrable(promise, create) {
  const p = asNew(promise, create);
  if (mark.get(p, 'deferrable')) return p;
  mark.set(p, 'deferrable');
  const px = deferred();
  p.resolve = px.resolve;
  p.reject = px.reject;
  return intercept(p, py => {
    py.then(val => px.resolve(val)).catch(reason => px.reject(reason));
    return px;
  });
}

function delay(ms, delayRejection = false) {
  const init = Date.now();

  const delayer = () => {
    const time = Date.now() - init;
    const remaining = Math.max(0, ms - time);
    return wait(remaining);
  };

  function trunk(promise, create) {
    return intercept(asNew(promise, create), px => {
      return px.then(val => delayer().then(() => val)).catch(err => {
        return delayRejection ? delayer().then(() => Promise.reject(err)) : Promise.reject(err);
      });
    });
  }

  return trunk;
}

function status(promise, create) {
  const p = asNew(promise, create);
  if (mark.get(p, 'status')) return p;
  mark.set(p, 'status');
  p.status = 'pending';
  p.value = null;
  p.reason = null;
  return intercept(p, px => {
    return px.then(val => {
      p.status = 'resolved';
      p.value = val;
      return val;
    }).catch(err => {
      p.status = 'rejected';
      p.reason = err;
      return Promise.reject(err);
    });
  });
}

function timed(promise, create) {
  const p = asNew(promise, create);
  if (mark.get(p, 'timed')) return p;
  mark.set(p, 'timed');
  p.time = null;
  const init = Date.now();
  return intercept(p, px => {
    return px.then(val => {
      p.time = Date.now() - init;
      return val;
    }).catch(err => {
      p.time = Date.now() - init;
      return Promise.reject(err);
    });
  });
}

function timeout(ms, reason) {
  function trunk(promise, create) {
    const shouldCancel = reason === undefined || reason === false;
    const p = cancellable(deferrable(asNew(promise, create)));
    let done = false;
    let timeout;
    new Promise(resolve => timeout = setTimeout(resolve, ms)).then(() => {
      if (done) return;
      if (shouldCancel) return p.cancel();
      if (typeof reason !== 'boolean') return p.reject(reason);
      p.reject(Error('Promise timed out'));
    });
    return intercept(p, px => {
      return px.then(val => {
        done = true;
        clearTimeout(timeout);
        return val;
      }).catch(err => {
        done = true;
        clearTimeout(timeout);
        return Promise.reject(err);
      });
    });
  }

  return trunk;
}

function compose(...fns) {
  const fn = trunk(...fns);
  return (promise, create) => fn(asNew(promise, create));
}
function trunk(...fns) {
  if (fns.length === 0) return arg => arg;
  if (fns.length === 1) return fns[0];
  return fns.reduce((a, b) => (...args) => a(b(...args)));
}

function control(test, generator) {
  return async (...args) => {
    const iterator = generator(...args);
    let value;
    let done;
    let testRes;

    while (!done && (testRes = await test()) && !(testRes instanceof Error)) {
      const next = iterator.next((await value));
      value = next.value;
      done = next.done;
    }

    if (testRes instanceof Error) throw testRes;
    return testRes ? value : new Promise(() => {});
  };
}

function map(arr, fn) {
  const ans = [];
  return arr.reduce((acc, x, i) => {
    return acc.then(() => x).then(val => fn(val, i, arr)).then(res => ans.push(res));
  }, Promise.resolve()).then(() => ans);
}
function filter(arr, fn) {
  const ans = [];
  return arr.reduce((acc, x, i) => {
    return acc.then(() => x).then(val => Promise.resolve(fn(val, i, arr)).then(res => res && ans.push(val)));
  }, Promise.resolve()).then(() => ans);
}
function reduce(arr, fn, initialValue) {
  return arr.slice(1).reduce((acc, x, i) => acc.then(val => Promise.resolve(x).then(x => fn(val, x, i + 1, arr))), initialValue === undefined ? Promise.resolve(arr[0]) : Promise.resolve(initialValue).then(val => Promise.resolve(arr[0]).then(x => fn(val, x, 0, arr))));
}
function each(arr, fn) {
  return arr.reduce((acc, x, i) => {
    return acc.then(() => x).then(val => fn(val, i, arr));
  }, Promise.resolve()).then(() => {});
}
var series = {
  map,
  filter,
  reduce,
  each
};

function map$1(arr, fn) {
  return Promise.all(arr).then(resArr => Promise.all(resArr.map(fn)));
}
function filter$1(arr, fn) {
  const filterVal = {};
  return Promise.all(arr).then(resArr => Promise.all(resArr.map((x, i) => Promise.resolve(fn(x, i, resArr)).then(ans => ans ? x : filterVal)))).then(arr => arr.filter(x => x !== filterVal));
}
function reduce$1(arr, fn, initialValue) {
  return Promise.all(arr).then(resArr => {
    return resArr.slice(1).reduce((acc, x, i) => {
      const p = deferred();
      acc.then(val => p.resolve(val)).catch(err => p.reject(err));
      return fn(p, x, i + 1, resArr);
    }, initialValue === undefined ? Promise.resolve(resArr[0]) : Promise.resolve(fn(Promise.resolve(initialValue), resArr[0], 0, resArr)));
  });
}
function each$1(arr, fn) {
  return map$1(arr, fn).then(() => {});
}
var parallel = {
  map: map$1,
  filter: filter$1,
  reduce: reduce$1,
  each: each$1
};

exports.cancellable = cancellable;
exports.compose = compose;
exports.control = control;
exports.deferrable = deferrable;
exports.deferred = deferred;
exports.delay = delay;
exports.immediate = immediate;
exports.isPromise = isPromise;
exports.lazy = lazy;
exports.parallel = parallel;
exports.series = series;
exports.status = status;
exports.timed = timed;
exports.timeout = timeout;
exports.wait = wait;
exports.waitUntil = waitUntil;
